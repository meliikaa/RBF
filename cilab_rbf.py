# -*- coding: utf-8 -*-
"""ciLab_RBF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18BgTK5PRwhkODXvrF1Pnq8XsS3O7iixA
"""

from numpy.linalg import norm
import numpy as np
import pandas as pd
import math as m
import matplotlib.pyplot as plt 

# Writing to an excel
## sheet using Python
import xlwt
from xlwt import Workbook
## Workbook is created
wb = Workbook()
## add_sheet is used to create sheet.
sheet1 = wb.add_sheet('Sheet 1')

#noise + data
NUM_SAMPLES = 100
XX = np.random.uniform(0., 1., NUM_SAMPLES)
XX = np.sort(XX, axis=0)
noise = np.random.uniform(-0.1, 0.1, NUM_SAMPLES)
y = np.sin(2*np.pi*XX)  + noise

# sheet.write is used to write in the sheet.
for i in range(1,NUM_SAMPLES+1):
  sheet1.write(i,0, XX[i-1])
sheet1.write(0, 0, 'X')
# saving the sheet
wb.save('xlwt example.xls')
# Read and store content of an excel file
read_file = pd.read_excel ("xlwt example.xls")
# Write the dataframe object into csv file
read_file.to_csv ("Test.csv",
                  index = None,
                  header=True)  
# read csv file and convert into a dataframe object
df = pd.DataFrame(pd.read_csv("Test.csv"))
data = pd.read_csv("Test.csv") 


#finding the number of class
def CNUM(x):
  s=0
  for i in range (k):
    A = float(x - center_x[i])
    #dist[i]= m.sqrt(A**2 + B**2)
    dist[i]= (A**2)
    if dist[i] == min(dist):
      s = i 
  return s

#classification
def classify(x):
   for j in range (data_number):
     X = data.iloc[[j],[0]].values
     X = float(X)
     index = CNUM(X)
     A[index].append([float(X)])
   return A


# Data 
data_number = input('Enter the number of data')
data_number = int(data_number)
k = input('Enter the number of class')
k = int(k)
center_x_new = np.empty(k)
center_x = np.empty(k)
dist = np.empty(k)
CLASS = [[]for _ in range (k)]
E22= [0 for _ in range (k)]
Error=[[]for _ in range (k)]
A = [[]for _ in range (k)]
flag = 1 
data = pd.read_excel("xlwt example.xls") 
lr = 0.01


# Center initializing
for i in range (k):
  center_x[i] = np.random.uniform(size=(1,1)) 


CLASS= classify(data_number)

#Finding new centers  
for o in range (k):
  if CLASS[o] != []:
    m =np.mean(CLASS[o], axis=0)
    #print(m)
    center_x_new[o] = float(m[0])

#Reclassification by new centers
while flag:
  for i in range (k):
    C = center_x_new[i]- center_x[i]
    C = C.astype('float')
    E2 = C**2
    E22[i] = C**2
    if (np.sum(E22) < (0.001)**2):
      flag = 0 
    if E2 > (0.001)**2:
      center_x[i] = center_x_new[i]
  CLASS= classify(data_number)
MAX = []
MIN = []
d = []
for i in range(k):
  if CLASS[i] == []:
    d.append(0)
  else:
    MAX.append(np.max(np.abs(CLASS[i])))
    MIN.append(np.min(np.abs(CLASS[i])))
    d.append((MAX[i]-MIN[i])/(1.414*k)) 
s = d
c = center_x
print(s)
print(c)
#RBF
def rbf(x, c, s):
  #j = m.sqrt(2*m.pi*s**2)
  j = (2.506*s)
  return(np.exp((-(x-c)**2)) / (2*s**2*j))

w = np.random.rand(k)
b = np.random.randn(1)
y_pre = []


# training
#for epoch in range(1000):
for i in range(NUM_SAMPLES):
  F = 0;
  for m in range(k):
    # forward pass
    a = np.array([rbf(XX[i], c[m], s[m]*500)])
    F = F + a.dot(w[m].T) + b

    print(a.dot(w[m].T) + b)
    #if epoch==500:
  y_pre.append(F)
  loss = (y[i] - F)** 2
7  # backward pass
  error = -(y[i] - F)
  # online update
  w = w - lr *a*error
  b = b - lr * error

plt.plot(XX, y, '-g', label='true')
print(XX)
print(y_pre)
plt.plot(XX, y_pre, '-r', label='RBF-Net')
plt.legend()
plt.tight_layout()
plt.show()